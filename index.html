<!DOCTYPE html>
<html>
<head>
    <title>Cave Game | Interactive Map</title>
    <style>
        #map { height: 800px; width: 800px; margin: auto; position: relative; }
        #controls { text-align: center; margin-top: 20px; }
        #info-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #sheep-selector-box {
            position: absolute;
            top: 100px;
            right: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #cave-selector-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #color-controls {
            position: absolute;
            top: 200px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        .color-input {
            margin-bottom: 10px;
        }
        svg {
            display: block;
        }
    </style>
</head>
<body>
<div id="map">
    <div id="info-box">
        <p id="cell-info">Click on a cell to get infos</p>
    </div>
    <div id="sheep-selector-box">
        <select id="sheep-selector">
            <option value="">Select a sheep</option>
        </select>
    </div>
    <div id="cave-selector-box">
        <p id="current-cave">Current Cave: No Cave Selected</p>
        <input type="number" id="cave-number" placeholder="Enter cave number" />
        <button id="cave-btn">Load Cave</button>
    </div>
    <div id="color-controls">
        <div class="color-input">
            <label for="color-unrevealed">Unrevealed:</label>
            <input type="color" id="color-unrevealed">
        </div>
        <div class="color-input">
            <label for="color-revealed">Revealed:</label>
            <input type="color" id="color-revealed">
        </div>
        <div class="color-input">
            <label for="color-actual">Actual:</label>
            <input type="color" id="color-actual">
        </div>
        <div class="color-input">
            <label for="color-diggable">Diggable:</label>
            <input type="color" id="color-diggable">
        </div>
        <div class="color-input">
            <label for="color-digged">Digged:</label>
            <input type="color" id="color-digged">
        </div>
        <div class="color-input">
            <label for="color-walls">Walls:</label>
            <input type="color" id="color-walls">
        </div>
        <div class="color-input">
            <label for="color-dutyfree">Duty-Free:</label>
            <input type="color" id="color-dutyfree">
        </div>
        <button id="apply-colors-btn">Apply Colors</button>
        <button id="reset-colors-btn">Reset Colors</button>
    </div>
</div>
<div id="controls">
    <input type="number" id="x-coord" placeholder="X" />
    <input type="number" id="y-coord" placeholder="Y" />
    <button id="center-btn">Center</button>
</div>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>
    const BACKEND_URL = 'cavegame.slkzgm.com';

    const width = 800;
    const height = 800;
    const gridSize = 400;
    const cellSize = 2;

    let COLORS = {
        UNREVEALED: "#333333",
        REVEALED: "#cccccc",
        ACTUAL: "#ffffff",
        DIGGABLE: "#ffd900",
        DIGGED: "#59e134",
        WALLS: "#ff0000",
        DUTYFREE: "#956565"
    };

    function loadColors() {
        const savedColors = JSON.parse(localStorage.getItem('colors'));
        if (savedColors) {
            COLORS = savedColors;
        }
        document.getElementById('color-unrevealed').value = COLORS.UNREVEALED;
        document.getElementById('color-revealed').value = COLORS.REVEALED;
        document.getElementById('color-actual').value = COLORS.ACTUAL;
        document.getElementById('color-diggable').value = COLORS.DIGGABLE;
        document.getElementById('color-digged').value = COLORS.DIGGED;
        document.getElementById('color-walls').value = COLORS.WALLS;
        document.getElementById('color-dutyfree').value = COLORS.DUTYFREE;
    }

    function saveColors() {
        localStorage.setItem('colors', JSON.stringify(COLORS));
    }

    const CELL_TYPE = {
        2: { top: true, right: true, bottom: true },
        4: { left: true, top: true, bottom: true },
        6: { top: true, bottom: true },
        8: { left: true, bottom: true, right: true },
        10: { right: true, bottom: true },
        12: { left: true, bottom: true },
        14: { bottom: true },
        16: { left: true, right: true, top: true },
        18: { top: true, right: true },
        20: { left: true, top: true },
        22: { top: true },
        24: { left: true, right: true },
        26: { right: true },
        28: { left: true },
        30: {},
        50: { right: true, bottom: true, top: true },
        52: { left: true, bottom: true, top: true },
        54: { top: true, bottom: true },
        56: { left: true, bottom: true, right: true },
        58: { right: true, bottom: true },
        60: { left: true, bottom: true },
        62: { bottom: true },
        64: { left: true, right: true, top: true },
        66: { top: true, right: true },
        68: { left: true, top: true },
        70: { top: true },
        72: { left: true, right: true },
        74: { right: true },
        76: { left: true },
        78: {}
    }

    const svg = d3.select("#map").append("svg")
        .attr("width", width)
        .attr("height", height);

    const container = svg.append("g");

    const zoom = d3.zoom()
        .scaleExtent([0.5, 10])
        .on("zoom", (event) => {
            container.attr("transform", event.transform);
        });

    svg.call(zoom);

    let sheepData = {};
    let currentCaveId = null;
    let socket = null;

    function drawGrid() {
        const centerX = 200;
        const centerY = 200;
        const halfSize = 10;

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const fillColor = (i >= centerX - halfSize && i < centerX + halfSize && j >= centerY - halfSize && j < centerY + halfSize) ? COLORS.DUTYFREE : COLORS.UNREVEALED;

                container.append("rect")
                    .attr("x", i * cellSize)
                    .attr("y", j * cellSize)
                    .attr("width", cellSize)
                    .attr("height", cellSize)
                    .attr("stroke", "black")
                    .attr("stroke-width", 0.25)
                    .attr("fill", fillColor)
                    .attr("diggable", "false")
                    .attr("revealed", "false")
                    .attr("border-drawn", "false")
                    .attr("coord-x", i)
                    .attr("coord-y", j)
                    .on("click", () => {
                        const rect = container.select(`rect[coord-x="${i}"][coord-y="${j}"]`);
                        const revealed = rect.attr("revealed");
                        const diggable = rect.attr("diggable");

                        document.getElementById('cell-info').innerHTML = `Position: (${i}, ${j})<br>Revealed: ${revealed}<br>Diggable: ${diggable}`;
                    });
            }
        }
    }

    function drawVisible(visibleCell) {
        const { x, y, directions, diggable } = visibleCell;
        const rect = container.select(`rect[coord-x="${x}"][coord-y="${y}"]`);

        // Attribuer revealed et diggable
        if (rect.attr("revealed") === "false") {
            rect.attr("revealed", "true");
            rect.attr("diggable", diggable.toString())

            // Colorer la case
            rect.attr("fill", diggable ? COLORS.DIGGABLE : COLORS.REVEALED);
        }

        // Dessiner les bordures si pas deja fait
        if (rect.attr("border-drawn") === "false") {
            const borders = CELL_TYPE[directions];

            if (borders) {
                if (borders.left) {
                    container.append("line")
                        .attr("x1", x * cellSize)
                        .attr("y1", y * cellSize)
                        .attr("x2", x * cellSize)
                        .attr("y2", y * cellSize + cellSize)
                        .attr("stroke", COLORS.WALLS)
                        .attr("stroke-width", 0.5);
                }
                if (borders.top) {
                    container.append("line")
                        .attr("x1", x * cellSize)
                        .attr("y1", y * cellSize)
                        .attr("x2", x * cellSize + cellSize)
                        .attr("y2", y * cellSize)
                        .attr("stroke", COLORS.WALLS)
                        .attr("stroke-width", 0.5);
                }
                if (borders.right) {
                    container.append("line")
                        .attr("x1", x * cellSize + cellSize)
                        .attr("y1", y * cellSize)
                        .attr("x2", x * cellSize + cellSize)
                        .attr("y2", y * cellSize + cellSize)
                        .attr("stroke", COLORS.WALLS)
                        .attr("stroke-width", 0.5);
                }
                if (borders.bottom) {
                    container.append("line")
                        .attr("x1", x * cellSize)
                        .attr("y1", y * cellSize + cellSize)
                        .attr("x2", x * cellSize + cellSize)
                        .attr("y2", y * cellSize + cellSize)
                        .attr("stroke", COLORS.WALLS)
                        .attr("stroke-width", 0.5);
                }
            }
            rect.attr("border-drawn", "true");
        }
    }

    function setActualCell(x, y) {
        const rect = container.select(`rect[coord-x="${x}"][coord-y="${y}"]`);

        rect.attr("fill", COLORS.ACTUAL);
    }

    function setHistoryCell(x, y) {
        const rect = container.select(`rect[coord-x="${x}"][coord-y="${y}"]`);

        const diggable = rect.attr("diggable");

        rect
            .attr("fill", diggable === "true" ? COLORS.DIGGED : COLORS.REVEALED)
            .attr("revealed", "true");
    }

    function processAndRenderData(data) {
        data.forEach(item => {
            const { sheepId, totalSteps, history, visible, coordinates: { x, y }, diggable } = item;

            // Stocker les informations sur les moutons
            sheepData[sheepId] = { totalSteps, coordinates: { x, y } };

            // // Dessiner les murs
            visible.forEach(drawVisible);

            // Colorer les cellules de l'historique
            history.forEach(position => {
                const x = Math.floor(position % gridSize);
                const y = Math.floor(position / gridSize);

                setHistoryCell(x, y);
            });

            // Colorer la position actuelle
            setActualCell(x, y);
        });

        updateSheepSelector();
    }

    function updateSheepSelector() {
        const sheepSelector = document.getElementById('sheep-selector');
        sheepSelector.innerHTML = '<option value="">Select a sheep</option>';

        Object.keys(sheepData).forEach(sheepId => {
            const { coordinates: { x, y } } = sheepData[sheepId];
            const option = document.createElement('option');
            option.value = sheepId;
            option.textContent = `Sheep ${sheepId} (x: ${x}, y: ${y})`;
            sheepSelector.appendChild(option);
        });
    }

    function centerOnSheep(sheepId) {
        const { coordinates: { x, y } } = sheepData[sheepId];
        const currentTransform = d3.zoomTransform(svg.node());
        const scale = currentTransform.k;
        const translateX = width / 2 - x * cellSize * scale;
        const translateY = height / 2 - y * cellSize * scale;
        const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
        svg.transition().duration(750).call(zoom.transform, transform);
    }

    function loadCaveData(caveId) {
        fetch(`https://${BACKEND_URL}/data?collectionName=${caveId}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('current-cave').innerText = `Current Cave: ${caveId}`;
                processAndRenderData(data);
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }

    function connectWebSocket() {
        socket = new WebSocket(`wss://${BACKEND_URL}`);

        socket.addEventListener('open', function () {
            console.log('Connected to WebSocket');
        });

        socket.addEventListener('message', function (event) {
            const data = JSON.parse(event.data);
            if (data.caveId === currentCaveId) {
                console.log('Message from server ', data);
                processAndRenderData([data]);
            }
        });

        socket.addEventListener('close', function () {
            console.error('WebSocket closed, attempting to reconnect in 5 seconds...');
            setTimeout(connectWebSocket, 5000); // Reconnect after 5 seconds
        });

        socket.addEventListener('error', function (event) {
            console.error('WebSocket error, attempting to reconnect in 5 seconds...', event);
            socket.close();
            setTimeout(connectWebSocket, 5000); // Reconnect after 5 seconds
        });
    }

    function changeCave(caveId) {
        currentCaveId = caveId;
        document.getElementById('current-cave').innerText = `Current Cave: ${caveId}`;
        container.selectAll("rect").remove();
        sheepData = {};
        drawGrid();
        loadCaveData(caveId);
    }

    document.getElementById('center-btn').addEventListener('click', function() {
        const x = parseInt(document.getElementById('x-coord').value) * cellSize;
        const y = parseInt(document.getElementById('y-coord').value) * cellSize;
        const currentTransform = d3.zoomTransform(svg.node());
        const scale = currentTransform.k;
        const translateX = width / 2 - x * scale;
        const translateY = height / 2 - y * scale;
        const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
        svg.transition().duration(750).call(zoom.transform, transform);
    });

    document.getElementById('sheep-selector').addEventListener('change', function() {
        const sheepId = this.value;
        if (sheepId) {
            centerOnSheep(sheepId);
        }
    });

    document.getElementById('cave-btn').addEventListener('click', function() {
        const caveId = parseInt(document.getElementById('cave-number').value);
        changeCave(caveId);
    });

    document.getElementById('apply-colors-btn').addEventListener('click', function() {
        COLORS.UNREVEALED = document.getElementById('color-unrevealed').value;
        COLORS.REVEALED = document.getElementById('color-revealed').value;
        COLORS.ACTUAL = document.getElementById('color-actual').value;
        COLORS.DIGGABLE = document.getElementById('color-diggable').value;
        COLORS.DIGGED = document.getElementById('color-digged').value;
        COLORS.WALLS = document.getElementById('color-walls').value;
        COLORS.DUTYFREE = document.getElementById('color-dutyfree').value;

        saveColors();

        // Redessiner la grille avec les nouvelles couleurs
        container.selectAll("rect").remove();
        drawGrid();
        if (currentCaveId) {
            loadCaveData(currentCaveId);
        }
    });

    document.getElementById('reset-colors-btn').addEventListener('click', function() {
        // Valeurs par défaut
        const defaultColors = {
            UNREVEALED: "#333333",
            REVEALED: "#cccccc",
            ACTUAL: "#ffffff",
            DIGGABLE: "#ffd900",
            DIGGED: "#59e134",
            WALLS: "#ff0000",
            DUTYFREE: "#956565"
        };

        // Mettre à jour les couleurs
        COLORS = defaultColors;

        // Mettre à jour les champs de saisie de couleur
        document.getElementById('color-unrevealed').value = COLORS.UNREVEALED;
        document.getElementById('color-revealed').value = COLORS.REVEALED;
        document.getElementById('color-actual').value = COLORS.ACTUAL;
        document.getElementById('color-diggable').value = COLORS.DIGGABLE;
        document.getElementById('color-digged').value = COLORS.DIGGED;
        document.getElementById('color-walls').value = COLORS.WALLS;
        document.getElementById('color-dutyfree').value = COLORS.DUTYFREE;

        // Sauvegarder les couleurs par défaut dans localStorage
        saveColors();

        // Redessiner la grille avec les couleurs par défaut
        container.selectAll("rect").remove();
        drawGrid();
        if (currentCaveId) {
            loadCaveData(currentCaveId);
        }
    });

    if (socket === null) {
        connectWebSocket()
    }

    // Charger les couleurs depuis localStorage au démarrage
    loadColors();
</script>
</body>
</html>