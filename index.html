<!DOCTYPE html>
<html>
<head>
    <title>Cave Game | Interactive Map</title>
    <style>
        #map { height: 800px; width: 800px; margin: auto; position: relative; }
        #controls { text-align: center; margin-top: 20px; }
        #info-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #sheep-selector-box {
            position: absolute;
            top: 120px;
            right: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #cave-selector-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        #color-controls {
            position: absolute;
            top: 200px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
        }
        .color-input {
            margin-bottom: 10px;
        }
        svg {
            display: block;
        }
        .tab-buttons {
            text-align: center;
            margin-bottom: 20px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        #details-container {
            height: 800px;
            width: 800px;
            margin: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: left;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #details-box {
            width: 100%;
            max-height: 100%;
            overflow-y: auto;
        }
        #details-box h2, #details-box h3 {
            text-align: center;
        }
        #details-box p, #details-box ul {
            margin: 10px 0;
        }
        .info-group {
            display: flex;
            justify-content: space-between;
        }
        .info-group p {
            flex: 1;
            margin: 0 10px;
        }
        .info-group p:first-child {
            margin-left: 0;
        }
        .info-group p:last-child {
            margin-right: 0;
        }
        .refresh-button {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<div class="tab-buttons">
    <button class="tab-button" onclick="showTab('tab1')">Map View</button>
    <button class="tab-button" onclick="showTab('tab2')">Last Cave Details</button>
</div>

<div id="tab1" class="tab-content active">
    <div id="map">
        <div id="info-box">
            <p id="cell-info">Click on a cell to get infos</p>
        </div>
        <div id="sheep-selector-box">
            <select id="sheep-selector">
                <option value="">Select a sheep</option>
            </select>
        </div>
        <div id="cave-selector-box">
            <p id="current-cave">Current Cave: No Cave Selected</p>
            <input type="number" id="cave-number" placeholder="Enter cave number" />
            <button id="cave-btn">Load Cave</button>
        </div>
        <div id="color-controls">
            <div class="color-input">
                <label for="color-unrevealed">Unrevealed:</label>
                <input type="color" id="color-unrevealed">
            </div>
            <div class="color-input">
                <label for="color-revealed">Revealed:</label>
                <input type="color" id="color-revealed">
            </div>
            <div class="color-input">
                <label for="color-actual">Actual:</label>
                <input type="color" id="color-actual">
            </div>
            <div class="color-input">
                <label for="color-diggable">Diggable:</label>
                <input type="color" id="color-diggable">
            </div>
            <div class="color-input">
                <label for="color-digged">Digged:</label>
                <input type="color" id="color-digged">
            </div>
            <div class="color-input">
                <label for="color-walls">Walls:</label>
                <input type="color" id="color-walls">
            </div>
            <div class="color-input">
                <label for="color-dutyfree">Duty-Free:</label>
                <input type="color" id="color-dutyfree">
            </div>
            <button id="apply-colors-btn">Apply Colors</button>
            <button id="reset-colors-btn">Reset Colors</button>
        </div>
    </div>
    <div id="controls">
        <input type="number" id="x-coord" placeholder="X" />
        <input type="number" id="y-coord" placeholder="Y" />
        <button id="center-btn">Center</button>
    </div>
</div>

<div id="tab2" class="tab-content">
    <div id="details-container">
        <div id="details-box"></div>
    </div>
    <div class="refresh-button">
        <button onclick="fetchLastCaveDetails()">Refresh Data</button>
    </div>
</div>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>
    const BACKEND_URL = 'cavegame.slkzgm.com';

    const width = 800;
    const height = 800;
    const gridSize = 400;
    const cellSize = 2;

    let COLORS = {
        UNREVEALED: "#333333",
        REVEALED: "#cccccc",
        ACTUAL: "#ffffff",
        DIGGABLE: "#00fff7",
        DIGGED: "#0050b7",
        WALLS: "#ff0000",
        DUTYFREE: "#956565"
    };

    function loadColors() {
        const savedColors = JSON.parse(localStorage.getItem('colors'));
        if (savedColors) {
            COLORS = savedColors;
        }
        document.getElementById('color-unrevealed').value = COLORS.UNREVEALED;
        document.getElementById('color-revealed').value = COLORS.REVEALED;
        document.getElementById('color-actual').value = COLORS.ACTUAL;
        document.getElementById('color-diggable').value = COLORS.DIGGABLE;
        document.getElementById('color-digged').value = COLORS.DIGGED;
        document.getElementById('color-walls').value = COLORS.WALLS;
        document.getElementById('color-dutyfree').value = COLORS.DUTYFREE;
    }

    function saveColors() {
        localStorage.setItem('colors', JSON.stringify(COLORS));
    }

    const CELL_TYPE = {
        2: { top: true, right: true, bottom: true },
        4: { left: true, top: true, bottom: true },
        6: { top: true, bottom: true },
        8: { left: true, bottom: true, right: true },
        10: { right: true, bottom: true },
        12: { left: true, bottom: true },
        14: { bottom: true },
        16: { left: true, right: true, top: true },
        18: { top: true, right: true },
        20: { left: true, top: true },
        22: { top: true },
        24: { left: true, right: true },
        26: { right: true },
        28: { left: true },
        30: {},
        50: { right: true, bottom: true, top: true },
        52: { left: true, bottom: true, top: true },
        54: { top: true, bottom: true },
        56: { left: true, bottom: true, right: true },
        58: { right: true, bottom: true },
        60: { left: true, bottom: true },
        62: { bottom: true },
        64: { left: true, right: true, top: true },
        66: { top: true, right: true },
        68: { left: true, top: true },
        70: { top: true },
        72: { left: true, right: true },
        74: { right: true },
        76: { left: true },
        78: {}
    }

    let heatColor = (movements) => {
        if (movements === 1) {
            return 'green';
        }
        if (movements <= 3) {
            return 'yellow';
        }
        if (movements <= 8) {
            return 'orange';
        }
        if (movements > 8) {
            return 'red';
        }
    }

    const svg = d3.select("#map").append("svg")
        .attr("width", width)
        .attr("height", height);

    const container = svg.append("g");

    const zoom = d3.zoom()
        .scaleExtent([0.5, 10])
        .on("zoom", (event) => {
            container.attr("transform", event.transform);
        });

    svg.call(zoom);

    let sheepData = {};
    let currentCaveId = null;
    let socket = null;

    function drawGrid() {
        const centerX = 200;
        const centerY = 200;
        const halfSize = 10;

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const fillColor = (i >= centerX - halfSize && i < centerX + halfSize && j >= centerY - halfSize && j < centerY + halfSize) ? COLORS.DUTYFREE : COLORS.UNREVEALED;

                container.append("rect")
                    .attr("x", i * cellSize)
                    .attr("y", j * cellSize)
                    .attr("width", cellSize)
                    .attr("height", cellSize)
                    .attr("stroke", "black")
                    .attr("stroke-width", 0.25)
                    .attr("fill", fillColor)
                    .attr("diggable", "false")
                    .attr("revealed", "false")
                    .attr("movements", "0")
                    .attr("border-drawn", "false")
                    .attr("coord-x", i)
                    .attr("coord-y", j)
                    .on("click", () => {
                        const rect = container.select(`rect[coord-x="${i}"][coord-y="${j}"]`);
                        const revealed = rect.attr("revealed");
                        const diggable = rect.attr("diggable");
                        const movements = rect.attr("movements");

                        document.getElementById('cell-info').innerHTML = `Position: (${i}, ${j})<br>Revealed: ${revealed}<br>Diggable: ${diggable}<br>Movements: ${movements}`;
                    });
            }
        }
    }

    function drawVisible(visibleCell) {
        let { x, y, directions, diggable, movements } = visibleCell;
        const rect = container.select(`rect[coord-x="${x}"][coord-y="${y}"]`);

        // Attribuer revealed et diggable
        rect.attr("revealed", "true");
        rect.attr("diggable", diggable.toString())

        if (!movements) {
            movements = parseInt(rect.attr("movements"));
        }

        // Colorer la case
        if (movements > 0) {
            rect.attr("fill", heatColor(movements));
            rect.attr("movements", movements.toString());
        } else {
            rect.attr("fill", diggable ? COLORS.DIGGABLE : COLORS.REVEALED);
        }

        // Dessiner les bordures
        const borders = CELL_TYPE[directions];

        if (borders) {
            if (borders.left) {
                container.append("line")
                    .attr("x1", x * cellSize)
                    .attr("y1", y * cellSize)
                    .attr("x2", x * cellSize)
                    .attr("y2", y * cellSize + cellSize)
                    .attr("stroke", COLORS.WALLS)
                    .attr("stroke-width", 0.5);
            }
            if (borders.top) {
                container.append("line")
                    .attr("x1", x * cellSize)
                    .attr("y1", y * cellSize)
                    .attr("x2", x * cellSize + cellSize)
                    .attr("y2", y * cellSize)
                    .attr("stroke", COLORS.WALLS)
                    .attr("stroke-width", 0.5);
            }
            if (borders.right) {
                container.append("line")
                    .attr("x1", x * cellSize + cellSize)
                    .attr("y1", y * cellSize)
                    .attr("x2", x * cellSize + cellSize)
                    .attr("y2", y * cellSize + cellSize)
                    .attr("stroke", COLORS.WALLS)
                    .attr("stroke-width", 0.5);
            }
            if (borders.bottom) {
                container.append("line")
                    .attr("x1", x * cellSize)
                    .attr("y1", y * cellSize + cellSize)
                    .attr("x2", x * cellSize + cellSize)
                    .attr("y2", y * cellSize + cellSize)
                    .attr("stroke", COLORS.WALLS)
                    .attr("stroke-width", 0.5);
            }
        }
        rect.attr("border-drawn", "true");
    }

    function processAndRenderData(data) {
        const toDraw = Object.values(data.reduce((acc, currentObj) => {
            const { sheepId, totalSteps, coordinates: { x, y }} = currentObj;
            const rect = container.select(`rect[coord-x="${x}"][coord-y="${y}"]`);

            sheepData[sheepId] = { totalSteps, coordinates: { x, y } };
            rect.attr("movements", "1")

            currentObj.visible.forEach(element => {
                acc[element.position] = element;
            });
            return acc;
        }, {}));

        toDraw.forEach(drawVisible);
        updateSheepSelector();
    }

    function updateSheepSelector() {
        const sheepSelector = document.getElementById('sheep-selector');
        sheepSelector.innerHTML = '<option value="">Select a sheep</option>';

        Object.keys(sheepData).forEach(sheepId => {
            const { coordinates: { x, y } } = sheepData[sheepId];
            const option = document.createElement('option');

            container.select(`rect[coord-x="${x}"][coord-y="${y}"]`).attr("fill", COLORS.ACTUAL);
            option.value = sheepId;
            option.textContent = `Sheep ${sheepId} (x: ${x}, y: ${y})`;
            sheepSelector.appendChild(option);
        });
    }

    function centerOnSheep(sheepId) {
        const { coordinates: { x, y } } = sheepData[sheepId];
        const currentTransform = d3.zoomTransform(svg.node());
        const scale = currentTransform.k;
        const translateX = width / 2 - x * cellSize * scale;
        const translateY = height / 2 - y * cellSize * scale;
        const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
        svg.transition().duration(750).call(zoom.transform, transform);
    }

    function loadCaveData(caveId) {
        fetch(`https://${BACKEND_URL}/cave?caveId=${caveId}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('current-cave').innerText = `Current Cave: ${caveId}`;
                processAndRenderData(data);
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }

    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    const reconnectDelay = 10000;  // Délai de reconnexion initial de 10 secondes

    function connectWebSocket() {
        if (socket !== null) {
            // Nettoyage des écouteurs pour éviter les doublons
            socket.removeEventListener('open', handleSocketOpen);
            socket.removeEventListener('message', handleSocketMessage);
            socket.removeEventListener('close', handleSocketClose);
            socket.removeEventListener('error', handleSocketError);
            socket.close();
        }

        socket = new WebSocket(`wss://${BACKEND_URL}/ws`);

        socket.addEventListener('open', handleSocketOpen);
        socket.addEventListener('message', handleSocketMessage);
        socket.addEventListener('close', handleSocketClose);
        socket.addEventListener('error', handleSocketError);
    }

    function handleSocketOpen() {
        console.log('Connected to WebSocket');
        reconnectAttempts = 0;  // Réinitialiser les tentatives de reconnexion
    }

    function handleSocketMessage(event) {
        const { type, data } = JSON.parse(event.data);
        if (type === 'move') {
            if (data.caveId === currentCaveId) {
                console.log('Move message from server ', data);
                processAndRenderData([data]);
            }
        } else {
            console.log('Message from server ', data);
        }
    }

    function handleSocketClose() {
        console.error('WebSocket closed, attempting to reconnect...');
        attemptReconnect();
    }

    function handleSocketError(event) {
        console.error('WebSocket error, attempting to reconnect...', event);
        attemptReconnect();
    }

    let reconnectTimeout;
    function attemptReconnect() {
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            clearTimeout(reconnectTimeout);
            reconnectTimeout = setTimeout(connectWebSocket, reconnectDelay);
        } else {
            console.error('Max reconnect attempts reached. Please check the server.');
        }
    }

    function changeCave(caveId) {
        currentCaveId = caveId;
        document.getElementById('current-cave').innerText = `Current Cave: ${caveId}`;
        container.selectAll("rect").remove();
        sheepData = {};
        drawGrid();
        loadCaveData(caveId);
    }

    document.getElementById('center-btn').addEventListener('click', function() {
        const x = parseInt(document.getElementById('x-coord').value) * cellSize;
        const y = parseInt(document.getElementById('y-coord').value) * cellSize;
        const currentTransform = d3.zoomTransform(svg.node());
        const scale = currentTransform.k;
        const translateX = width / 2 - x * scale;
        const translateY = height / 2 - y * scale;
        const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
        svg.transition().duration(750).call(zoom.transform, transform);
    });

    document.getElementById('sheep-selector').addEventListener('change', function() {
        const sheepId = this.value;
        if (sheepId) {
            centerOnSheep(sheepId);
        }
    });

    document.getElementById('cave-btn').addEventListener('click', function() {
        const caveId = parseInt(document.getElementById('cave-number').value);
        changeCave(caveId);
    });

    document.getElementById('apply-colors-btn').addEventListener('click', function() {
        COLORS.UNREVEALED = document.getElementById('color-unrevealed').value;
        COLORS.REVEALED = document.getElementById('color-revealed').value;
        COLORS.ACTUAL = document.getElementById('color-actual').value;
        COLORS.DIGGABLE = document.getElementById('color-diggable').value;
        COLORS.DIGGED = document.getElementById('color-digged').value;
        COLORS.WALLS = document.getElementById('color-walls').value;
        COLORS.DUTYFREE = document.getElementById('color-dutyfree').value;

        saveColors();

        // Redessiner la grille avec les nouvelles couleurs
        container.selectAll("rect").remove();
        drawGrid();
        if (currentCaveId) {
            loadCaveData(currentCaveId);
        }
    });

    document.getElementById('reset-colors-btn').addEventListener('click', function() {
        // Mettre à jour les couleurs
        COLORS = {
            UNREVEALED: "#333333",
            REVEALED: "#cccccc",
            ACTUAL: "#ffffff",
            DIGGABLE: "#00fff7",
            DIGGED: "#0050b7",
            WALLS: "#ff0000",
            DUTYFREE: "#956565"
        };

        // Mettre à jour les champs de saisie de couleur
        document.getElementById('color-unrevealed').value = COLORS.UNREVEALED;
        document.getElementById('color-revealed').value = COLORS.REVEALED;
        document.getElementById('color-actual').value = COLORS.ACTUAL;
        document.getElementById('color-diggable').value = COLORS.DIGGABLE;
        document.getElementById('color-digged').value = COLORS.DIGGED;
        document.getElementById('color-walls').value = COLORS.WALLS;
        document.getElementById('color-dutyfree').value = COLORS.DUTYFREE;

        // Sauvegarder les couleurs par défaut dans localStorage
        saveColors();

        // Redessiner la grille avec les couleurs par défaut
        container.selectAll("rect").remove();
        drawGrid();
        if (currentCaveId) {
            loadCaveData(currentCaveId);
        }
    });

    if (socket === null) {
        connectWebSocket()
    }

    // Charger les couleurs depuis localStorage au démarrage
    loadColors();

    function showTab(tabId) {
        const tabs = document.querySelectorAll('.tab-content');
        tabs.forEach(tab => {
            tab.classList.remove('active');
        });

        const selectedTab = document.getElementById(tabId);
        selectedTab.classList.add('active');
    }

    async function fetchLastCaveDetails() {
        try {
            const response = await fetch(`https://${BACKEND_URL}/lastCave`);
            const caveDetails = await response.json();
            displayCaveDetails(caveDetails);
        } catch (error) {
            console.error('Error fetching last cave details:', error);
        }
    }

    function displayCaveDetails(caveDetails) {
        const detailsBox = document.getElementById('details-box');
        detailsBox.innerHTML = `
                <h2>Cave Details</h2>
                <div class="info-group">
                    <p><strong>ID:</strong> ${caveDetails.id}</p>
                    <p><strong>Size:</strong> ${caveDetails.size}</p>
                    <p><strong>Starts At:</strong> ${new Date(caveDetails.startsAt).toLocaleString()}</p>
                    <p><strong>Ends At:</strong> ${new Date(caveDetails.endsAt).toLocaleString()}</p>
                </div>
                <div class="info-group">
                    <p><strong>Cave Closed:</strong> ${caveDetails.caveClosed}</p>
                    <p><strong>Map File Visible:</strong> ${caveDetails.mapFileVisible}</p>
                    <p><strong>Rope Available:</strong> ${caveDetails.ropeAvailable}</p>
                </div>
                <h3>Population</h3>
                <div class="info-group">
                    <p><strong>Sheep Population:</strong> ${caveDetails.sheepPopulation}</p>
                    <p><strong>Wolf Population:</strong> ${caveDetails.wolfPopulation}</p>
                </div>
                <h3>Loot</h3>
                <div class="info-group">
                    <p><strong>Items:</strong> ${caveDetails.items}</p>
                    <p><strong>Found Wool:</strong> ${caveDetails.foundWool}</p>
                    <p><strong>Cave Points:</strong> ${caveDetails.cavePoints}</p>
                </div>
                <h3>Found Items</h3>
                <ul>
                    ${Object.entries(caveDetails.found).map(([item, count]) => `<li><strong>${item}:</strong> ${count}</li>`).join('')}
                </ul>
            `;
    }

    // Fetch cave details when the second tab is shown
    document.querySelector('.tab-button:nth-child(2)').addEventListener('click', fetchLastCaveDetails);
</script>
</body>
</html>